<!DOCTYPE html>
<html>
    <head></head>
    <body>
        <div>
        <h1>Data Structures & Aigorithms</h1>
        </div>
        <script>
            /**************************Hackerrank***************************/

            // Competetive gaming
            let k = 4;
            scores = [2,2,3,4,5];
            const numPlayers = (K, scores) => {
                let sorted = scores.sort((a, b) => b - a);
                let players = sorted.filter(n => n >= sorted[3]);
               return players.length;
            }
            let num = numPlayers(k, scores);
            //console.log(num);

            // Disk space Analysis
            let x = 2;
            let space = [8,2,4,6];
            const segment = (x, space) => {
                let minNums = [];
                for (let i = 0; i < space.length - 1; i++) {
                  let min = Math.min(space[i], space[i + 1]);
                  minNums.push(min);
                }
                return Math.max(...minNums);
            }
            let max = segment(x, space);
            //console.log(max);

            // Parking Dilemma
            let cars = [1,2,3,10];
            let m = 4;
            const carParkingRoof = (cars, m) => {
                let sortedCars = cars.sort((a,b) => a - b);
                let lastCarIndex = sortedCars.length - 1;
                if (m < cars.length) { 
                    let roofOneLength = sortedCars[m - 1] - sortedCars[0] + 1;
                    let roofTwoLength = sortedCars[lastCarIndex] - sortedCars[m - 2] + 1;
                    return Math.min(roofOneLength, roofTwoLength)
                }
                return sortedCars[m - 1] - sortedCars[0] + 1;
            }
            let roofLength = carParkingRoof(cars, m);
            //console.log(roofLength);
            
            
            /***************************LeetCode*************************/

            /*-------String Manipulation-----*/

            // Reverse String
            const reverseString = (s) => {
                s.reverse();
            };

            // Valid Palindrome
            const isPalindrome = (s) => {
                let cleanStr = cleanUp(s);

                return isPal(cleanStr);
            }
            
            function cleanUp(str) {
                let char = "abcdefghijklmnopqrstuvwxyz0123456789";

                let newStr = '';

                for (let i = 0; i < str.length; i++) {
                    let lCase = str[i].toLowerCase();

                    if (char.indexOf(lCase) !== -1) {
                        newStr += lCase;
                    }
                }
                return newStr;
            }

            function isPal(str) {
                let left = 0;
                let right = str.length - 1;

                while (left < right) {
                    if (str[left] !== str[right]) {
                        return false;
                    }
                    left++;
                    right--;
                }
                return true
            }

            console.log(isPalindrome("A man, a plan, a canal: panama"));


            /*--------Array--------------*/

            // Two Sum
            const twoSum = (nums, target) => {
                let cache = {}
                for (num in nums) {
                    let num2 = target - nums[num];
                    if (num2 in cache) {
                        return [num, cache[num2]]
                    }
                    cache[nums[num]] = num;
                }
            };

            console.log(twoSum([3,2,4], 6));


            /*--------Sorting---------*/

            //Valid Anagram
            const isAnagram = (s, t) => {
                if (s.length !== t.length) return false;
                let map = {};

                for (let i = 0; i < s.length; i++) {
                    let letter = s[i];

                    if (!map[letter]) {
                        map[letter] = 1;
                    } else {
                        map[letter]++
                    }
                }
                for (let i = 0; i < t.length; i++) {
                    let letter = t[i];

                    if (map[letter] === undefined) {
                        return false;
                    }
                    if (map[letter] < 1) {
                        return false;
                    }
                    map[letter]--;
                }

                return true;
            }

            console.log(isAnagram('anagram', 'nagaram'));

            // Array Partition 1
            const arrayPairSum = (nums) => {
                let res = 0;

                nums.sort((a, b) => a - b);
                for (let i = 0; i < nums.length; i = i + 2) {
                    res += nums[i];
                }
                return res;
            }

            console.log(arrayPairSum([1,4,3,2]));


            /*-----Divide and conquer algorithm-----*/

            //Merge K Sorted Lists
            function mergeList(a, b) {
                let dummy = new ListNode(0);
                let current = dummy;

                while(a !== null && b !== null) {
                    if (a.val < b.val) {
                        current.next = a;
                        a = a.next;
                    } else {
                        current.next = b;
                        b = b.next;
                    }
                    current = current.next;
                }
                current.next = a || b;

                return dummy.next;
            }
            
            const mergeKLists = (lists) => {
                if (lists.length === 0) {
                    return null;
                }

                while(lists.length > 1) {
                    let a = lists.shift();
                    let b = lists.shift();
                    let mergedAB = mergeList(a, b);
                    lists.push(mergedAB);
                }

                return lists[0];
            }


            /*-------Stack---------------*/

            // Valid Parenthese
            const isValid = (s) => {
                let stack = [];
                let len = s.length;
                const map = {
                    '(': ')',
                    '[': ']',
                    '{': '}'
                };
                for (let i = 0; i < len; i++) {
                    if (stack.length > 0 && map[stack[stack.length - 1]] === s[i]) {
                    stack.pop();
                    } else {
                    stack.push(s[i]);
                    }
                }
                return stack.length === 0;
            };

            console.log(isValid("(]"));



            /*------Linked lists -------*/

            // Add Two Numbers
            const addTwoNumbers = (l1, l2) => {
                let head = new ListNode(0);
                let node = head;
                let carry = 0;
                while (l1 || l2) {
                    let l1Value = l1 ? l1.val : 0;
                    let l2Value = l2 ? l2.val : 0;

                    let sum = l1Value + l2Value + carry;
                    carry = 0;
                    let newValue = sum;

                    if (sum > 9) {
                        newValue = sum % 10;
                        carry = 1;
                    }

                    node.next = new ListNode(newValue);
                    node = node.next;
                    
                    if (l1) {
                        l1 = l1.next;
                    }

                    if (l2) {
                        l2 = l2.next;
                    }
                }

                if (carry) {
                    node.next = new ListNode(carry);
                }

                return head.next;
            }

            // Reverse List
            function reverseList(head) {
                let prev = null;
                let next = null;

                while (head !== null) {
                    next = head.next;
                    head.next = prev;
                    prev = head;
                    head = next;
                }
                return prev;
            }

            /*--------Trees---------------*/

            // Validate Binary Search Tree
            const isValidBST = (root) => {
                function recurse(root, min, max) {
                    // base cases
                    if (root === null) return true;

                    if((root.val >= max || root.val <= min)) {
                        return false;
                    }

                    //recurrence relation
                    return recurse(root.left, min, root.val) && recurse(root.right, root.val, max);
                }
                return recurse(root, -Infinity, Infinity)
            }

            /*-------Hashmaps and sets-------*/

            // Group Anagrams
            const groupAnagrams = (strs) => {
                let obj = {}

                for(let i of strs) {
                    let key = i.split('').sort().join('');

                    if(!obj[key]) {
                        obj[key] = [i];
                    } else {
                        obj[key].push(i);
                    }
                }
                return Object.values(obj)
            }

            console.log(groupAnagrams(["eat","tea","tan","ate","nat","bat"]));

            /*------Recursion and Memoization-----*/

            // Powx-n
            const pow = (x, n) => {
                function helper(x, n) {
                    if (x === 0) return 0;
                    if (n === 0) return 1;

                    let result = pow(x, Math.floor(n / 2));
                    let total = result * result;
                    if (n % 2) {
                        return x * total;
                    } else {
                        return total;
                    }
                }

                let ans = helper(x, Math.abs(n));
                if (n >= 0) {
                    return ans;
                } else {
                    return 1 / ans;
                }
                
            }
            
            console.log(pow(2, 10));

            /*---------Queues--------*/

            // First unique character in a string
            const firstUniqChar = (s) => {
                let occurance = {};
                for (let i = 0; i < s.length; i++) {
                    if (!occurance[s[i]]) {
                        occurance[s[i]] = 1;
                    } else {
                        occurance[s[i]] += 1;
                    }
                }

                for (let i = 0; i < s.length; i++) {
                    let value = occurance[s[i]];
                    if (value === 1) {
                        return i;
                    }
                }
                return -1;
            }

            console.log(firstUniqChar("leetcode"));

            /*---------Graph---------*/

            // Course Schedule
            const canFinish = (numCourses, prerequisites) => {
                const graph = Array.from(Array(numCourses), () => []);
                const ranks = Array(numCourses).fill(0);
                for (const [u,v] of prerequisites) {
                    graph[v].push(u);
                    ++ranks[u];
                }
                const queue = [];
                //push nodes with no dependency (rank 0) to queue
                ranks.forEach((r, i) => {
                    if (!r) queue.push(i);
                })
                //bfs kahn
                while (queue.length) {
                    const f = queue.shift();
                    --numCourses;
                    //reduce neighbour rank by 1
                    //push nodes with no dependency (rank 0) to queue
                    graph[f].forEach(neigh => {
                        if (!--ranks[neigh]) queue.push(neigh);
                    })
                }
                return !numCourses;
            }

            console.log(canFinish(2, [[1,0], [0,1]]))

        </script>
    </body>
</html>